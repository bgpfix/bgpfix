// Code generated by "enumer -type Type -trimprefix TYPE_"; DO NOT EDIT.

package mrt

import (
	"fmt"
	"strings"
)

const (
	_TypeName_0      = "INVALID"
	_TypeLowerName_0 = "invalid"
	_TypeName_1      = "OSPF2TABLE_DUMPTABLE_DUMP2"
	_TypeLowerName_1 = "ospf2table_dumptable_dump2"
	_TypeName_2      = "BGP4MPBGP4MP_ET"
	_TypeLowerName_2 = "bgp4mpbgp4mp_et"
	_TypeName_3      = "ISISISIS_ET"
	_TypeLowerName_3 = "isisisis_et"
	_TypeName_4      = "OSPF3OSPF3_ET"
	_TypeLowerName_4 = "ospf3ospf3_et"
)

var (
	_TypeIndex_0 = [...]uint8{0, 7}
	_TypeIndex_1 = [...]uint8{0, 5, 15, 26}
	_TypeIndex_2 = [...]uint8{0, 6, 15}
	_TypeIndex_3 = [...]uint8{0, 4, 11}
	_TypeIndex_4 = [...]uint8{0, 5, 13}
)

func (i Type) String() string {
	switch {
	case i == 0:
		return _TypeName_0
	case 11 <= i && i <= 13:
		i -= 11
		return _TypeName_1[_TypeIndex_1[i]:_TypeIndex_1[i+1]]
	case 16 <= i && i <= 17:
		i -= 16
		return _TypeName_2[_TypeIndex_2[i]:_TypeIndex_2[i+1]]
	case 32 <= i && i <= 33:
		i -= 32
		return _TypeName_3[_TypeIndex_3[i]:_TypeIndex_3[i+1]]
	case 48 <= i && i <= 49:
		i -= 48
		return _TypeName_4[_TypeIndex_4[i]:_TypeIndex_4[i+1]]
	default:
		return fmt.Sprintf("Type(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _TypeNoOp() {
	var x [1]struct{}
	_ = x[TYPE_INVALID-(0)]
	_ = x[TYPE_OSPF2-(11)]
	_ = x[TYPE_TABLE_DUMP-(12)]
	_ = x[TYPE_TABLE_DUMP2-(13)]
	_ = x[TYPE_BGP4MP-(16)]
	_ = x[TYPE_BGP4MP_ET-(17)]
	_ = x[TYPE_ISIS-(32)]
	_ = x[TYPE_ISIS_ET-(33)]
	_ = x[TYPE_OSPF3-(48)]
	_ = x[TYPE_OSPF3_ET-(49)]
}

var _TypeValues = []Type{TYPE_INVALID, TYPE_OSPF2, TYPE_TABLE_DUMP, TYPE_TABLE_DUMP2, TYPE_BGP4MP, TYPE_BGP4MP_ET, TYPE_ISIS, TYPE_ISIS_ET, TYPE_OSPF3, TYPE_OSPF3_ET}

var _TypeNameToValueMap = map[string]Type{
	_TypeName_0[0:7]:        TYPE_INVALID,
	_TypeLowerName_0[0:7]:   TYPE_INVALID,
	_TypeName_1[0:5]:        TYPE_OSPF2,
	_TypeLowerName_1[0:5]:   TYPE_OSPF2,
	_TypeName_1[5:15]:       TYPE_TABLE_DUMP,
	_TypeLowerName_1[5:15]:  TYPE_TABLE_DUMP,
	_TypeName_1[15:26]:      TYPE_TABLE_DUMP2,
	_TypeLowerName_1[15:26]: TYPE_TABLE_DUMP2,
	_TypeName_2[0:6]:        TYPE_BGP4MP,
	_TypeLowerName_2[0:6]:   TYPE_BGP4MP,
	_TypeName_2[6:15]:       TYPE_BGP4MP_ET,
	_TypeLowerName_2[6:15]:  TYPE_BGP4MP_ET,
	_TypeName_3[0:4]:        TYPE_ISIS,
	_TypeLowerName_3[0:4]:   TYPE_ISIS,
	_TypeName_3[4:11]:       TYPE_ISIS_ET,
	_TypeLowerName_3[4:11]:  TYPE_ISIS_ET,
	_TypeName_4[0:5]:        TYPE_OSPF3,
	_TypeLowerName_4[0:5]:   TYPE_OSPF3,
	_TypeName_4[5:13]:       TYPE_OSPF3_ET,
	_TypeLowerName_4[5:13]:  TYPE_OSPF3_ET,
}

var _TypeNames = []string{
	_TypeName_0[0:7],
	_TypeName_1[0:5],
	_TypeName_1[5:15],
	_TypeName_1[15:26],
	_TypeName_2[0:6],
	_TypeName_2[6:15],
	_TypeName_3[0:4],
	_TypeName_3[4:11],
	_TypeName_4[0:5],
	_TypeName_4[5:13],
}

// TypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func TypeString(s string) (Type, error) {
	if val, ok := _TypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _TypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Type values", s)
}

// TypeValues returns all values of the enum
func TypeValues() []Type {
	return _TypeValues
}

// TypeStrings returns a slice of all String values of the enum
func TypeStrings() []string {
	strs := make([]string, len(_TypeNames))
	copy(strs, _TypeNames)
	return strs
}

// IsAType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Type) IsAType() bool {
	for _, v := range _TypeValues {
		if i == v {
			return true
		}
	}
	return false
}
