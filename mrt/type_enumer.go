// Code generated by "enumer -type Type"; DO NOT EDIT.

package mrt

import (
	"fmt"
	"strings"
)

const (
	_TypeName_0      = "INVALID"
	_TypeLowerName_0 = "invalid"
	_TypeName_1      = "OSPF2TABLE_DUMPTABLE_DUMP2"
	_TypeLowerName_1 = "ospf2table_dumptable_dump2"
	_TypeName_2      = "BGP4MPBGP4MP_ET"
	_TypeLowerName_2 = "bgp4mpbgp4mp_et"
	_TypeName_3      = "ISISISIS_ET"
	_TypeLowerName_3 = "isisisis_et"
	_TypeName_4      = "OSPF3OSPF3_ET"
	_TypeLowerName_4 = "ospf3ospf3_et"
)

var (
	_TypeIndex_0 = [...]uint8{0, 7}
	_TypeIndex_1 = [...]uint8{0, 5, 15, 26}
	_TypeIndex_2 = [...]uint8{0, 6, 15}
	_TypeIndex_3 = [...]uint8{0, 4, 11}
	_TypeIndex_4 = [...]uint8{0, 5, 13}
)

func (i Type) String() string {
	switch {
	case i == 0:
		return _TypeName_0
	case 11 <= i && i <= 13:
		i -= 11
		return _TypeName_1[_TypeIndex_1[i]:_TypeIndex_1[i+1]]
	case 16 <= i && i <= 17:
		i -= 16
		return _TypeName_2[_TypeIndex_2[i]:_TypeIndex_2[i+1]]
	case 32 <= i && i <= 33:
		i -= 32
		return _TypeName_3[_TypeIndex_3[i]:_TypeIndex_3[i+1]]
	case 48 <= i && i <= 49:
		i -= 48
		return _TypeName_4[_TypeIndex_4[i]:_TypeIndex_4[i+1]]
	default:
		return fmt.Sprintf("Type(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _TypeNoOp() {
	var x [1]struct{}
	_ = x[INVALID-(0)]
	_ = x[OSPF2-(11)]
	_ = x[TABLE_DUMP-(12)]
	_ = x[TABLE_DUMP2-(13)]
	_ = x[BGP4MP-(16)]
	_ = x[BGP4MP_ET-(17)]
	_ = x[ISIS-(32)]
	_ = x[ISIS_ET-(33)]
	_ = x[OSPF3-(48)]
	_ = x[OSPF3_ET-(49)]
}

var _TypeValues = []Type{INVALID, OSPF2, TABLE_DUMP, TABLE_DUMP2, BGP4MP, BGP4MP_ET, ISIS, ISIS_ET, OSPF3, OSPF3_ET}

var _TypeNameToValueMap = map[string]Type{
	_TypeName_0[0:7]:        INVALID,
	_TypeLowerName_0[0:7]:   INVALID,
	_TypeName_1[0:5]:        OSPF2,
	_TypeLowerName_1[0:5]:   OSPF2,
	_TypeName_1[5:15]:       TABLE_DUMP,
	_TypeLowerName_1[5:15]:  TABLE_DUMP,
	_TypeName_1[15:26]:      TABLE_DUMP2,
	_TypeLowerName_1[15:26]: TABLE_DUMP2,
	_TypeName_2[0:6]:        BGP4MP,
	_TypeLowerName_2[0:6]:   BGP4MP,
	_TypeName_2[6:15]:       BGP4MP_ET,
	_TypeLowerName_2[6:15]:  BGP4MP_ET,
	_TypeName_3[0:4]:        ISIS,
	_TypeLowerName_3[0:4]:   ISIS,
	_TypeName_3[4:11]:       ISIS_ET,
	_TypeLowerName_3[4:11]:  ISIS_ET,
	_TypeName_4[0:5]:        OSPF3,
	_TypeLowerName_4[0:5]:   OSPF3,
	_TypeName_4[5:13]:       OSPF3_ET,
	_TypeLowerName_4[5:13]:  OSPF3_ET,
}

var _TypeNames = []string{
	_TypeName_0[0:7],
	_TypeName_1[0:5],
	_TypeName_1[5:15],
	_TypeName_1[15:26],
	_TypeName_2[0:6],
	_TypeName_2[6:15],
	_TypeName_3[0:4],
	_TypeName_3[4:11],
	_TypeName_4[0:5],
	_TypeName_4[5:13],
}

// TypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func TypeString(s string) (Type, error) {
	if val, ok := _TypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _TypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Type values", s)
}

// TypeValues returns all values of the enum
func TypeValues() []Type {
	return _TypeValues
}

// TypeStrings returns a slice of all String values of the enum
func TypeStrings() []string {
	strs := make([]string, len(_TypeNames))
	copy(strs, _TypeNames)
	return strs
}

// IsAType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Type) IsAType() bool {
	for _, v := range _TypeValues {
		if i == v {
			return true
		}
	}
	return false
}
