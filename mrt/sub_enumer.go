// Code generated by "enumer -type Sub"; DO NOT EDIT.

package mrt

import (
	"fmt"
	"strings"
)

const (
	_SubName_0      = "BGP4_STATE_CHANGEBGP4_MESSAGE"
	_SubLowerName_0 = "bgp4_state_changebgp4_message"
	_SubName_1      = "BGP4_MESSAGE_AS4BGP4_STATE_CHANGE_AS4BGP4_MESSAGE_LOCALBGP4_MESSAGE_AS4_LOCALBGP4_MESSAGE_ADDPATHBGP4_MESSAGE_AS4_ADDPATHBGP4_MESSAGE_LOCAL_ADDPATHBGP4_MESSAGE_AS4_LOCAL_ADDPATH"
	_SubLowerName_1 = "bgp4_message_as4bgp4_state_change_as4bgp4_message_localbgp4_message_as4_localbgp4_message_addpathbgp4_message_as4_addpathbgp4_message_local_addpathbgp4_message_as4_local_addpath"
)

var (
	_SubIndex_0 = [...]uint8{0, 17, 29}
	_SubIndex_1 = [...]uint8{0, 16, 37, 55, 77, 97, 121, 147, 177}
)

func (i Sub) String() string {
	switch {
	case 0 <= i && i <= 1:
		return _SubName_0[_SubIndex_0[i]:_SubIndex_0[i+1]]
	case 4 <= i && i <= 11:
		i -= 4
		return _SubName_1[_SubIndex_1[i]:_SubIndex_1[i+1]]
	default:
		return fmt.Sprintf("Sub(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _SubNoOp() {
	var x [1]struct{}
	_ = x[BGP4_STATE_CHANGE-(0)]
	_ = x[BGP4_MESSAGE-(1)]
	_ = x[BGP4_MESSAGE_AS4-(4)]
	_ = x[BGP4_STATE_CHANGE_AS4-(5)]
	_ = x[BGP4_MESSAGE_LOCAL-(6)]
	_ = x[BGP4_MESSAGE_AS4_LOCAL-(7)]
	_ = x[BGP4_MESSAGE_ADDPATH-(8)]
	_ = x[BGP4_MESSAGE_AS4_ADDPATH-(9)]
	_ = x[BGP4_MESSAGE_LOCAL_ADDPATH-(10)]
	_ = x[BGP4_MESSAGE_AS4_LOCAL_ADDPATH-(11)]
}

var _SubValues = []Sub{BGP4_STATE_CHANGE, BGP4_MESSAGE, BGP4_MESSAGE_AS4, BGP4_STATE_CHANGE_AS4, BGP4_MESSAGE_LOCAL, BGP4_MESSAGE_AS4_LOCAL, BGP4_MESSAGE_ADDPATH, BGP4_MESSAGE_AS4_ADDPATH, BGP4_MESSAGE_LOCAL_ADDPATH, BGP4_MESSAGE_AS4_LOCAL_ADDPATH}

var _SubNameToValueMap = map[string]Sub{
	_SubName_0[0:17]:         BGP4_STATE_CHANGE,
	_SubLowerName_0[0:17]:    BGP4_STATE_CHANGE,
	_SubName_0[17:29]:        BGP4_MESSAGE,
	_SubLowerName_0[17:29]:   BGP4_MESSAGE,
	_SubName_1[0:16]:         BGP4_MESSAGE_AS4,
	_SubLowerName_1[0:16]:    BGP4_MESSAGE_AS4,
	_SubName_1[16:37]:        BGP4_STATE_CHANGE_AS4,
	_SubLowerName_1[16:37]:   BGP4_STATE_CHANGE_AS4,
	_SubName_1[37:55]:        BGP4_MESSAGE_LOCAL,
	_SubLowerName_1[37:55]:   BGP4_MESSAGE_LOCAL,
	_SubName_1[55:77]:        BGP4_MESSAGE_AS4_LOCAL,
	_SubLowerName_1[55:77]:   BGP4_MESSAGE_AS4_LOCAL,
	_SubName_1[77:97]:        BGP4_MESSAGE_ADDPATH,
	_SubLowerName_1[77:97]:   BGP4_MESSAGE_ADDPATH,
	_SubName_1[97:121]:       BGP4_MESSAGE_AS4_ADDPATH,
	_SubLowerName_1[97:121]:  BGP4_MESSAGE_AS4_ADDPATH,
	_SubName_1[121:147]:      BGP4_MESSAGE_LOCAL_ADDPATH,
	_SubLowerName_1[121:147]: BGP4_MESSAGE_LOCAL_ADDPATH,
	_SubName_1[147:177]:      BGP4_MESSAGE_AS4_LOCAL_ADDPATH,
	_SubLowerName_1[147:177]: BGP4_MESSAGE_AS4_LOCAL_ADDPATH,
}

var _SubNames = []string{
	_SubName_0[0:17],
	_SubName_0[17:29],
	_SubName_1[0:16],
	_SubName_1[16:37],
	_SubName_1[37:55],
	_SubName_1[55:77],
	_SubName_1[77:97],
	_SubName_1[97:121],
	_SubName_1[121:147],
	_SubName_1[147:177],
}

// SubString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func SubString(s string) (Sub, error) {
	if val, ok := _SubNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _SubNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Sub values", s)
}

// SubValues returns all values of the enum
func SubValues() []Sub {
	return _SubValues
}

// SubStrings returns a slice of all String values of the enum
func SubStrings() []string {
	strs := make([]string, len(_SubNames))
	copy(strs, _SubNames)
	return strs
}

// IsASub returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Sub) IsASub() bool {
	for _, v := range _SubValues {
		if i == v {
			return true
		}
	}
	return false
}
